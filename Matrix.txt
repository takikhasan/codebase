/*   Matrix   */

template<typename T>
struct Matrix
{
    vector<vector<T>> matrix;

    Matrix(int n, int m)
    {
        matrix = vector<vector<T>> (n, vector<T> (m, 0));
    }

    Matrix operator * (const Matrix& B) const
    {
        int n = SZ(matrix), m = SZ(B[0]);
        Matrix ret(n, m); int c = SZ(matrix[0]);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < c; k++) {
                    ret[i][j] += matrix[i][k] * B[k][j];
                }
            }
        }
        return ret;
    }

    template<typename P>
    Matrix pow(P p) {
        if (p == 1) return *this;
        Matrix ret = pow(p / 2);
        ret = ret * ret;
        if (p % 2) ret = ret * (*this);
        return ret;
    }

    vector<T>& operator [] (int u) { return matrix[u]; }
    const vector<T>& operator [] (int u) const { return matrix[u]; }
};

template<typename T>
struct Solver
{
    /**
     * T -> Data type required for storing result
     */
    template<typename N>
    T nthFib(N n, T x, T y) const
    {
        /**
         * x -> fib(0), y -> fib(1)
         */
        if (!n) return 0;
        Matrix<T> a(2, 2), b(2, 1);
        a[0][1] = a[1][0] = a[1][1] = 1;
        b[0][0] = x; b[1][0] = y;
        return (a.pow(n) * b)[0][0];
    }
};

/*   Matrix   */